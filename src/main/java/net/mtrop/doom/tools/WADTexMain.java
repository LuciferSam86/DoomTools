/*******************************************************************************
 * Copyright (c) 2020 Matt Tropiano
 * This program and the accompanying materials are made available under 
 * the terms of the MIT License, which accompanies this distribution.
 ******************************************************************************/
package net.mtrop.doom.tools;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintStream;
import java.io.PrintWriter;
import java.nio.charset.Charset;

import net.mtrop.doom.WadFile;
import net.mtrop.doom.object.BinaryObject;
import net.mtrop.doom.struct.io.IOUtils;
import net.mtrop.doom.texture.CommonTextureList;
import net.mtrop.doom.texture.DoomTextureList;
import net.mtrop.doom.texture.PatchNames;
import net.mtrop.doom.texture.StrifeTextureList;
import net.mtrop.doom.texture.TextureSet;
import net.mtrop.doom.tools.common.Common;
import net.mtrop.doom.tools.common.ParseException;
import net.mtrop.doom.tools.common.Utility;
import net.mtrop.doom.util.NameUtils;
import net.mtrop.doom.util.TextureUtils;

/**
 * Main class for WADTex.
 * @author Matthew Tropiano
 */
public final class WADTexMain
{
	private static final String DOOM_VERSION = Common.getVersionString("doom");
	private static final String VERSION = Common.getVersionString("wadtex");

	private static final int ERROR_NONE = 0;
	private static final int ERROR_BAD_INPUTOUTPUT_FILE = 1;
	private static final int ERROR_BAD_PARSE = 2;
	private static final int ERROR_MISSING_DATA = 3;

	private static final String SWITCH_HELP = "--help";
	private static final String SWITCH_HELP2 = "-h";
	private static final String SWITCH_VERBOSE = "--verbose";
	private static final String SWITCH_VERBOSE2 = "-v";
	private static final String SWITCH_VERSION = "--version";
	private static final String SWITCH_EXPORT = "--export";
	private static final String SWITCH_EXPORT2 = "-x";
	private static final String SWITCH_IMPORT = "--import";
	private static final String SWITCH_IMPORT2 = "-i";
	private static final String SWITCH_ADDITIVE = "--add";
	private static final String SWITCH_ADDITIVE2 = "-a";
	private static final String SWITCH_STRIFE = "--strife";

	private static final String WADTEX_OUTPUT_HEADER = (new StringBuilder())
		.append("; File generated by WADTEX v").append(VERSION).append(" by Matt Tropiano").append('\n')
		.append("; This is also compatible with DEUTEX!")
	.toString();

	/**
	 * Program options.
	 */
	private static class Options
	{
		boolean help;
		boolean version;
		boolean verbose;
		boolean additive;
		boolean strife;
		Boolean exportMode;
		File sourceFile;
		File wadFile;
		
		Options()
		{
			this.help = false;
			this.version = false;
			this.verbose = false;
			this.additive = false;
			this.strife = false;
			this.exportMode = null;
			this.sourceFile = null;
			this.wadFile = null;
		}
	}
	
	/**
	 * Reads command line arguments and sets options.
	 * @param args the argument args.
	 */
	private static Options options(String[] args)
	{
		Options out = new Options();
		final int STATE_START = 0;
		final int STATE_IMPORTEXPORT = 1;
		int state = STATE_START;
		
		int i = 0;
		while (i < args.length)
		{
			String arg = args[i];
			switch (state)
			{
				case STATE_START:
				{
					if (arg.equals(SWITCH_HELP) || arg.equals(SWITCH_HELP2))
						out.help = true;
					else if (arg.equals(SWITCH_VERBOSE) || arg.equals(SWITCH_VERBOSE2))
						out.verbose = true;
					else if (arg.equals(SWITCH_ADDITIVE) || arg.equals(SWITCH_ADDITIVE2))
						out.additive = true;
					else if (arg.equals(SWITCH_STRIFE))
						out.strife = true;
					else if (arg.equals(SWITCH_VERSION))
						out.version = true;
					else if (arg.equals(SWITCH_EXPORT) || arg.equals(SWITCH_EXPORT2))
					{
						state = STATE_IMPORTEXPORT;
						out.exportMode = true;
					}
					else if (arg.equals(SWITCH_IMPORT) || arg.equals(SWITCH_IMPORT2))
					{
						state = STATE_IMPORTEXPORT;
						out.exportMode = false;
					}
					else
						out.wadFile = new File(arg);
				}
				break;

				case STATE_IMPORTEXPORT:
				{
					out.sourceFile = new File(arg);
					state = STATE_START;
				}
				break;
			}
			i++;
		}
		
		return out;
	}
	
	/**
	 * Prints the splash.
	 * @param out the print stream to print to.
	 */
	private static void splash(PrintStream out)
	{
		out.println("WADTex v" + VERSION + " by Matt Tropiano (using DoomStruct v" + DOOM_VERSION + ")");
	}

	/**
	 * Prints the usage.
	 * @param out the print stream to print to.
	 */
	private static void usage(PrintStream out)
	{
		out.println("Usage: wadtex [--help | -h | --version] [file] [mode] [switches]");
	}
	
	/**
	 * Prints the help.
	 * @param out the print stream to print to.
	 */
	private static void help(PrintStream out)
	{
		out.println("    --help              Prints help and exits.");
		out.println("    -h");
		out.println();
		out.println("    --version           Prints version, and exits.");
		out.println();
		out.println("[file]:");
		out.println("    <filename>          The WAD file.");
		out.println();
		out.println("[mode]:");
	    out.println("    --export [dstfile]  Export mode.");
	    out.println("    -x [dstfile]        Exports PNAMES and texture lump named [dstfile] from");
	    out.println("                        [file] to [dstfile].");
		out.println();
	    out.println("    --import [srcfile]  Import mode.");
	    out.println("    -i [srcfile]        Imports a DEUTEX file from [srcfile] into [file]");
	    out.println("                        and adds/modifies PNAMES and the texture lump (name is");
	    out.println("                        taken from file name).");
	    out.println("                        WAD file is created if it doesn't exist.");
		out.println();
	    out.println("    --add               Additive mode. If specified on import, this will");
	    out.println("    -a                  append the new data to an existing texture lump.");
	    out.println("                        PNAMES may still be altered.");
		out.println();
	    out.println("    --strife            Force Strife format on import (conversion or new).");
		out.println();
		out.println("[switches]:");
		out.println("    --verbose           Prints verbose output.");
		out.println("    -v");
	}
	
	@SuppressWarnings("unchecked")
	public static void main(String[] args)
	{
		Options options = options(args);
		
		if (options.help)
		{
			splash(System.out);
			usage(System.out);
			System.out.println();
			help(System.out);
			System.exit(ERROR_NONE);
		}
		
		if (options.version)
		{
			splash(System.out);
			System.exit(ERROR_NONE);
		}
		
		if (options.wadFile == null)
		{
			System.out.println("ERROR: No WAD file specified.");
			usage(System.out);
			System.exit(ERROR_MISSING_DATA);
			return;
		}

		if (options.exportMode == null)
		{
			System.out.println("ERROR: Import or export mode not specified.");
			usage(System.out);
			System.exit(ERROR_MISSING_DATA);
			return;
		}

		if (options.sourceFile == null)
		{
			System.out.println("ERROR: No source file specified.");
			usage(System.out);
			System.exit(ERROR_MISSING_DATA);
			return;
		}

		WadFile wad = null;
		try 
		{
			if (!options.exportMode && !options.wadFile.exists())
				wad = WadFile.createWadFile(options.wadFile);
			else
				wad = new WadFile(options.wadFile);
		}
		catch (FileNotFoundException e)
		{
			System.out.printf("ERROR: File %s not found.\n", options.wadFile.getPath());
			System.exit(ERROR_BAD_INPUTOUTPUT_FILE);
			return;
		}
		catch (IOException e)
		{
			System.out.printf("ERROR: %s.\n", e.getLocalizedMessage());
			System.exit(ERROR_BAD_INPUTOUTPUT_FILE);
			return;
		}
		catch (SecurityException e)
		{
			System.out.printf("ERROR: File %s not readable (access denied).\n", options.wadFile.getPath());
			System.exit(ERROR_BAD_INPUTOUTPUT_FILE);
			return;
		}

		String streamName = null;
		BufferedReader reader = null;
		PrintWriter writer = null;

		try
		{
			PatchNames patchNames;
			boolean replacePatchNames = true;
			if ((patchNames = wad.getDataAs("PNAMES", PatchNames.class)) == null)
			{
				patchNames = new PatchNames();
				replacePatchNames = false;
			}

			String textureLumpName = NameUtils.toValidEntryName(Common.getFileNameWithoutExtension(options.sourceFile));
			
			CommonTextureList<?> textures;
			boolean replaceTextures;
			boolean strife;
			if ((options.additive || options.exportMode) && wad.contains(textureLumpName))
			{
				replaceTextures = true;
				byte[] data = wad.getData(textureLumpName);
				if (TextureUtils.isStrifeTextureData(data))
				{
					strife = true;
					textures = BinaryObject.create(StrifeTextureList.class, data);
				}
				else
				{
					strife = false;
					textures = BinaryObject.create(DoomTextureList.class, data);
				}
			}
			else
			{
				textures = new DoomTextureList();
				strife = false;
				replaceTextures = false;
			}
			
			// Force Strife format if specified.
			if (options.strife)
				strife = true;
			
			TextureSet textureSet;
			
			if (options.exportMode)
			{
				textureSet = new TextureSet(patchNames, textures);

				try
				{
					writer = new PrintWriter(new FileOutputStream(options.sourceFile), true, Charset.forName("ASCII"));
					streamName = options.sourceFile.getPath();
				}
				catch (IOException e)
				{
					System.out.printf("ERROR: File %s not writable.\n", options.sourceFile.getPath());
					System.exit(ERROR_BAD_INPUTOUTPUT_FILE);
					return;
				}
				catch (SecurityException e)
				{
					System.out.printf("ERROR: File %s not writable (access denied).\n", options.sourceFile.getPath());
					System.exit(ERROR_BAD_INPUTOUTPUT_FILE);
					return;
				}

				Utility.writeDEUTEXFile(textureSet, WADTEX_OUTPUT_HEADER, writer);
				System.out.printf("Wrote `%s`.\n", streamName);
			}
			else // import mode
			{
				try
				{
					reader = new BufferedReader(new InputStreamReader(new FileInputStream(options.sourceFile)));
					streamName = options.sourceFile.getPath();
				}
				catch (FileNotFoundException e)
				{
					System.out.printf("ERROR: File %s not found.\n", options.sourceFile.getPath());
					System.exit(ERROR_BAD_INPUTOUTPUT_FILE);
					return;
				}
				catch (SecurityException e)
				{
					System.out.printf("ERROR: File %s not readable (access denied).\n", options.sourceFile.getPath());
					System.exit(ERROR_BAD_INPUTOUTPUT_FILE);
					return;
				}

				textureSet = Utility.readDEUTEXFile(reader, patchNames, textures);
				if (strife)
					textureSet.export(patchNames = new PatchNames(), (CommonTextureList<StrifeTextureList.Texture>)(textures = new StrifeTextureList(128)));
				else
					textureSet.export(patchNames = new PatchNames(), (CommonTextureList<DoomTextureList.Texture>)(textures = new DoomTextureList(128)));

				if (replacePatchNames)
				{
					wad.replaceEntry(wad.indexOf("PNAMES"), patchNames);
					if (options.verbose)
						System.out.printf("Replaced `PNAMES` in `%s`.\n", options.wadFile.getPath());
				}
				else
				{
					wad.addData("PNAMES", patchNames);
					if (options.verbose)
						System.out.printf("Added `PNAMES` to `%s`.\n", options.wadFile.getPath());
				}
				
				if (replaceTextures)
				{
					wad.replaceEntry(wad.indexOf(textureLumpName), textures);
					if (options.verbose)
						System.out.printf("Replaced `%s` in `%s`.\n", textureLumpName, options.wadFile.getPath());
				}
				else
				{
					wad.addData(textureLumpName, textures);
					if (options.verbose)
						System.out.printf("Added `%s` to `%s`.\n", textureLumpName, options.wadFile.getPath());
				}
				
				System.out.printf("Imported into `%s`.\n", options.wadFile.getPath());
			}
		}
		catch (IOException e)
		{
			System.out.printf("ERROR: %s\n", e.getLocalizedMessage());
			System.exit(ERROR_BAD_INPUTOUTPUT_FILE);
		}
		catch (ParseException e)
		{
			System.out.printf("ERROR: %s, %s\n", streamName, e.getLocalizedMessage());
			System.exit(ERROR_BAD_PARSE);
		}
		finally
		{
			IOUtils.close(reader);
			IOUtils.close(writer);
			IOUtils.close(wad);
		}
		
		System.exit(ERROR_NONE);
	}

}
